<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width">

	<link rel="stylesheet" type="text/css" href="/styles.css" />

	<script type="text/javascript">

		const _rootMenu =
			[{
				text: 'MAME-AO',
				title: 'MAME-AO',
				href: '/',
				menu: [
					{
						text: 'Machines',
						title: 'Start Machines',
						href: '/machines',
					},
					{
						text: 'Genres',
						title: 'Machines by Genre',
						href: '/genres',
					},
					{
						text: 'Saved State',
						title: 'View saved state & Previous MAME versions',
						href: '/saved',
					},
					{
						text: 'Reporting',
						title: 'Information Reporting',
						href: '/reports',
						menu: [
							{
								text: 'Run Reports',
								title: 'Run Reports',
								href: '/reports/run',
							},
							{
								text: 'View Reports',
								title: 'View Veports',
								href: '/reports/view',
							},
						],
					},
					{
						text: 'Store',
						title: 'Hash Store Operations',
						href: '/store',
					},
					{
						text: 'Snaps',
						title: 'Collect MAME snapshots into directory & Convert to SVG',
						href: '/snaps',
					},
					{
						text: 'Import',
						title: 'Import ROM/CHD from directory',
						href: '/import',
					},
					{
						text: 'Export',
						title: 'Export ROM/CHD standard MAME format',
						href: '/export',
					},
					{
						text: 'Settings',
						title: 'Settings - User Preferences',
						href: '/settings',
					},
					{
						text: 'BitTorrent',
						title: 'BitTorrent Client Information',
						href: '/bittorrent',
					},
					{
						text: 'About',
						title: 'About & System Information',
						href: '/about',
					},
				],
			}];

		//
		// Main
		//

		let _baseUrl;
		let _parameters;
		let _path;
		let _pathParts;
		let _info;
		let _currentMenu;
		let _updateAvailable = false;
		let _inTick = false;

		const main = async () => {

			try {

				getRequestInfo();

				await mainWork();

				await tick();
				setInterval(tick, 2000);

			} catch (error) {

				const div = document.getElementById('error');

				const html = `<h2>MAME-AO UI Error : ${error.name}</h2>` +
					'<p>If you want to submit an error report please copy and paste the error text from here. Maybe include a screen shot.</p>' +
					'<p>Copy (Ctrl+C) -> notepad -> paste (Ctrl+V).</p>' +
					'<p>Report issues here <a href="https://github.com/sam-ludlow/mame-ao/issues" target="_blank" >https://github.com/sam-ludlow/mame-ao/issues</a></p>' +
					'<hr />' +
					`<p>${error.stack}</p>` +
					'<hr />';

				div.innerHTML = html;
				div.style = 'background-color: pink;';

				throw error;
			}
		}

		//
		// Status tick
		//

		const tick = async () => {

			if (_inTick === true)
				return;

			_inTick = true;

			let status;

			try {
				status = await fetchJson('/api/status');
			}
			catch (e) {
				alert(`Problem connecting to MAME-AO server.\n\nHave you closed the console?\n\nStart MAME-AO again or close this window.\n\nError: ${e.message}`);
			}

			try {

				document.body.className = status.busy === true ? 'busy' : '';

				const topRow = document.getElementById('nav').children[0].rows[0];

				let statusElement = [...topRow.children].find(element => element.id === 'status');

				if (status.busy === false && statusElement)
					statusElement.remove();

				if (status.busy == true) {
					if (!statusElement) {
						statusElement = document.createElement('td');
						statusElement.id = 'status';
						topRow.appendChild(statusElement);
					}

					statusElement.style.textAlign = 'center';

					let message = `Running Command: "${status.command}"`;

					if (status.bytesTotal > 0) {
						const percent = ((100 / status.bytesTotal) * status.bytesCurrent).toFixed(2);
						message += `, Progress: ${status.bytesCurrent} of ${status.bytesTotal} (${percent}%)`;

						statusElement.style.color = percent < 30 ? '#ffffff' : '#000000';

						let red = (percent >= 50) ? Math.round((50 - (percent - 50)) * 5.1) : 255;
						let green = (percent < 50) ? Math.round(percent * 5.1) : 255;

						statusElement.style.backgroundColor = `rgb(${red}, ${green}, 0)`;
					} else {
						statusElement.style.backgroundColor = '#ffff00';
					}

					statusElement.innerHTML = message;
				}
			}
			finally {
				_inTick = false;
			}
		}

		const mainWork = async () => {

			//
			// Info & update check
			//

			_info = await fetchJson('/api/info');

			if (_info.version_name_current !== _info.version_name_available) {
				_rootMenu.push({
					text: `Update Available ${_info.version_name_current} => ${_info.version_name_available}`,
					title: `Update ${_info.version_name_current} => ${_info.version_name_available}`,
					href: '/update',
					style: 'background-color: #ffa500;',
				});
			}


			//
			// load machines menu
			//
			if (_pathParts.includes('/machines')) {
				const dataProfiles = await fetchJson('/api/profiles');

				_rootMenu[0].menu[0].menu = dataProfiles.results.map((profile) => {
					return {
						text: profile.text,
						title: profile.description,
						href: `/machines/${profile.key}`,
					};
				});
			}

			//
			// load software menu
			//
			let machineData;

			if (_pathParts.includes('/machines') && _pathParts.length >= 4) {

				let current;
				_rootMenu[0].menu[0].menu.forEach((item) => {
					if (_pathParts[2] === item.href)
						current = item;
				});

				if (current === undefined)
					throw new Error('current machine menu not found');

				let parts = _pathParts[2].split('/');
				const profileName = parts[parts.length - 1];

				parts = _pathParts[3].split('/');
				const machineName = parts[parts.length - 1];

				machineData = await fetchJson(`/api/machine?name=${machineName}`);

				current.menu = [{
					text: `${machineData.name} &bull; ${machineData.description}`,
					title: machineData.description,
					href: `/machines/${profileName}/${machineName}`,
				}];

				current.menu[0].menu = machineData.softwarelists.map((list) => {
					return {
						text: list.description,
						title: list.description,
						href: `/machines/${profileName}/${machineName}/${list.name}`,
					};
				});

				current.menu[0].menu.push({
					text: 'Favorites',
					title: 'Favorites',
					href: `/machines/${profileName}/${machineName}/@fav`,
				});

			}

			//
			// genre menu
			//

			if (_info.genre_version === '') {
				_rootMenu[0].menu.splice(1, 1);
			} else {
				if (_pathParts.includes('/genres') && _pathParts.length >= 3) {

					let parts = _pathParts[2].split('/');
					const group_name_enc = parts[parts.length - 1];
					const group_name = decodeURIComponent(group_name_enc);

					_rootMenu[0].menu[1].menu = [{
						text: group_name,
						title: group_name,
						href: `/genres/${group_name_enc}`,
					}];

					if (_pathParts.length >= 4) {

						parts = _pathParts[3].split('/');
						const genre_name_enc = parts[parts.length - 1];
						const genre_name = decodeURIComponent(genre_name_enc);

						_rootMenu[0].menu[1].menu[0].menu = [{
							text: genre_name,
							title: genre_name,
							href: `/genres/${group_name_enc}/${genre_name_enc}`,
						}];
					}
				}
			}

			displayMenu();

			//
			// Route
			//

			if (_pathParts.includes('/machines') && _pathParts.length === 3) {
				await machines();
				return;
			}

			if (_pathParts.includes('/machines') && _pathParts.length === 5) {
				await machine(machineData);
				return;
			}

			if (_pathParts.includes('/genres') && _pathParts.length === 3) {
				await genresGroup();
				return;
			}

			if (_pathParts.includes('/genres') && _pathParts.length === 4) {
				await genreMachines();
				return;
			}

			const routeFunction = {
				'/saved': saved,
				'/reports/run': runReports,
				'/reports/view': viewReports,
				'/update': update,
				'/store': storeOperations,
				'/snaps': collectSnaps,
				'/import': importFiles,
				'/export': exportFiles,
				'/genres': genres,
				'/settings': settings,
				'/bittorrent': bittorrent,
				'/about': about,
			}[_path];

			if (routeFunction !== undefined)
				await routeFunction();
		}

		//
		// Settings
		//
		const settings = async () => {

			const canvas = getCanvas();

			const data = await fetchJson('/api/settings');

			let html = '<hr />';

			Object.keys(data.available_options).forEach((key) => {
				html += `<h2>${key}</h2><p>${data.option_descriptions[key]}</p>`
				html += `<select id="settings_${key}" onchange="runCommand('.set ${key} ' + this.value)">`;

				data.available_options[key].forEach((option) => {
					html += `<option value="${option}">${option}</option>`;
				});

				html += '</select>';
				html += '<hr />';
			});


			let div = document.createElement('div');
			div.innerHTML = html;
			canvas.appendChild(div);

			Object.keys(data.available_options).forEach((key) => {
				document.getElementById(`settings_${key}`).value = data.options[key];
			});
		}

		//
		// BitTorrent
		//
		const bittorrent = async () => {

			const canvas = getCanvas();

			const refreshLink = '<p><a href="javascript:window.location.href=window.location.href">Refresh this page to see changes</a></p>';

			let div;
			let table;
			let columnDefs;

			if (_info.bit_torrent_enabled !== true) {

				div = document.createElement('div');
				div.innerHTML = '<h2>BitTorrent Currently Disabled</h2>' +
					'<p>Click button to enable immediately. You will have to Allow in Windows Firewall when the dialog apears.</p>' +
					'<button type="submit" onclick="runCommand(\'.bt\'); return false;">Enable BitTorrent</button>' +
					refreshLink;
				canvas.appendChild(div);
				return;
			}


			div = document.createElement('div');
			div.innerHTML = 'Connecting to DOME-BT ...';
			canvas.appendChild(div);

			let btInfo;
			try {
				btInfo = await fetchJson('/api/info', _info.bit_torrent_url);
				div.innerHTML = '';
			}
			catch (e) {
				div.innerHTML = `<h2>Error connecting to DOME-BT</h2><p>Ensure the DOME-BT process is running you can use the command ".bt" or click the button.</p><p>Error: ${e.message}</p>` +
					'<button type="submit" onclick="runCommand(\'.bt\'); return false;">Start BitTorrent</button>' +
					refreshLink;
				return;
			}

			// BitTorrent Client Information

			div = document.createElement('div');
			div.style = 'width:100%;';
			div.innerHTML = '<h2>BitTorrent Client Information</h2><table style="width:100%;">' +
				'<tr><th>Version</th><th>Start Time</th><th>Time Now</th><th>Running for</th></tr>' +
				`<tr><td>DOME-BT ${btInfo.version}</td><td>${btInfo.start_time}</td><td>${btInfo.time_now}</td><td>${btInfo.run_time_text}</td></tr>` +
				'</table>';
			canvas.appendChild(div);

			div = document.createElement('div');
			div.style = 'width:100%;';
			div.innerHTML = '<table style="width:100%;">' +
				'<tr><th>Open Connections</th><th>Download Rate</th><th>Upload Rate</th></tr>' +
				`<tr><td>${btInfo.open_connections}</td><td>${btInfo.total_download_rate_text}/s</td><td>${btInfo.total_upload_rate_text}/s</td></tr>` +
				'</table>';
			canvas.appendChild(div);

			div = document.createElement('div');
			div.style = 'width:100%;';
			div.innerHTML = '<table style="width:100%;">' +
				'<tr><th>Download Total</th><th>Upload Total</th></tr>' +
				`<tr><td>${btInfo.total_bytes_received_text}</td><td>${btInfo.total_bytes_sent_text}</td></tr>` +
				'</table>';
			canvas.appendChild(div);

			// BitTorrents

			div = document.createElement('div');
			div.style = 'width:100%;';
			div.innerHTML = '<hr /><h2>BitTorrents</h2>';
			canvas.appendChild(div);

			columnDefs = [
				{ heading: 'Name', columnName: 'name' },
				{ heading: 'State', columnName: 'state' },
				{ heading: 'File Count', columnName: 'file_count' },
				{ heading: 'Open Connections', columnName: 'open_connections' },
				{ heading: 'Peers Available', columnName: 'peers_available' },
				{ heading: 'Peers Leechs', columnName: 'peers_leechs' },
				{ heading: 'Peers Seeds', columnName: 'peers_seeds' },
				{ heading: 'Downloaded', columnName: 'bytes_received_text' },
				{ heading: 'Uploaded', columnName: 'bytes_sent_text' },
			];

			table = document.createElement('table');
			table.style = 'width:100%;';

			buildTable(columnDefs, btInfo.torrents, table, (columnDef, result, resultIndex, row, cell) => {

				const value = result[columnDef.columnName];

				if (value === undefined)
					return;

				switch (columnDef.columnName) {

					default:
						cell.innerHTML = value;
						break;
				}
			});
			canvas.appendChild(table);

			// Port Mappings

			div = document.createElement('div');
			div.innerHTML = '<hr /><h2>Port Mappings</h2>';
			canvas.appendChild(div);

			columnDefs = [
				{ heading: 'Name', columnName: 'name' },
				{ heading: 'Mappings', columnName: 'mappings' },
			];

			table = document.createElement('table');

			buildTable(columnDefs, btInfo.port_mappings, table, (columnDef, result, resultIndex, row, cell) => {

				const value = result[columnDef.columnName];

				if (value === undefined)
					return;

				switch (columnDef.columnName) {

					case 'mappings':
						cell.innerHTML = value.map(item => `${item.protocol}:${item.public_port}`).join(', ');
						break;

					default:
						cell.innerHTML = value;
						break;
				}
			});
			canvas.appendChild(table);

			// BitTorrent Client Details

			div = document.createElement('div');
			div.innerHTML = '<hr /><h2>BitTorrent Client Details</h2>';
			canvas.appendChild(div);

			const infoData = [];

			Object.keys(btInfo).forEach((key) => {

				if (Array.isArray(btInfo[key]) === true)
					return;

				infoData.push({ key: key, value: btInfo[key] });
			});

			table = document.createElement('table');

			columnDefs = [
				{ heading: 'Key', columnName: 'key' },
				{ heading: 'Value', columnName: 'value' },
			];

			buildTable(columnDefs, infoData, table, (columnDef, result, resultIndex, row, cell) => {

				const value = result[columnDef.columnName];

				if (value === undefined)
					return;

				cell.innerHTML = value;
			});

			canvas.appendChild(table);

			// Magnet Links

			div = document.createElement('div');
			div.innerHTML = '<hr /><h2>Magnet Links</h2>';
			canvas.appendChild(div);

			columnDefs = [
				{ heading: 'Asset Type', columnName: 'type' },
				{ heading: 'Name / Link', columnName: 'name' },
				{ heading: 'Version', columnName: 'version' },
				{ heading: 'Available', columnName: 'torrent_available' },
			];

			table = document.createElement('table');

			buildTable(columnDefs, btInfo.magnets, table, (columnDef, result, resultIndex, row, cell) => {

				const value = result[columnDef.columnName];

				if (value === undefined)
					return;

				switch (columnDef.columnName) {

					case 'name':
						cell.innerHTML = `<a href="${result.magnet_link}" target="_blank">${value}</a>`;
						break;
					default:
						cell.innerHTML = value;
						break;
				}
			});
			canvas.appendChild(table);

			// Disable

			div = document.createElement('div');
			div.innerHTML = '<hr /><h2>Disable BitTorrent</h2>' +
				'<p>Click button to disable & remove BitTorrent.</p>' +
				'<p>If you want to use archive.org for downloading assets use the command ".creds" to enter your credentials if you have not already.</p>' +
				'<button type="submit" onclick="runCommand(\'.btx\'); return false;">Disable BitTorrent</button>' +
				refreshLink;
			canvas.appendChild(div);
		}

		//
		// About
		//
		const about = async () => {

			const canvas = getCanvas();

			let html =
				`<h2>What's New in the latest MAME release</h2><a href="${_baseUrl}/api/what" target="_blank">Open whatsnew.txt</a><hr />` +
				'<h2>MAME-AO README on github</h2><a href="https://github.com/sam-ludlow/mame-ao#mame-ao" target="_blank">View instructions</a><hr />';

			if (_info.linking_enabled !== true)
				html += '<h2>Warning - Symbolic Links not enabled</h2><a href="https://github.com/sam-ludlow/mame-ao?tab=readme-ov-file#symbolic-links---save-disk-space" target="_blank">View instructions on enabling</a><hr />';

			html += '<h2>System Information</h2>';

			let div = document.createElement('div');
			div.innerHTML = html;
			canvas.appendChild(div);

			// System Information

			const infoData = [];

			Object.keys(_info).forEach((key) => {

				if (key === 'latest' || key === 'sources' || key === 'items' || key === 'repos')
					return;

				infoData.push({ key: key, value: _info[key] });
			});

			let table = document.createElement('table');

			let columnDefs = [
				{ heading: 'Key', columnName: 'key' },
				{ heading: 'Value', columnName: 'value' },
			];

			buildTable(columnDefs, infoData, table, (columnDef, result, resultIndex, row, cell) => {

				const value = result[columnDef.columnName];

				if (value === undefined)
					return;

				cell.innerHTML = value;
			});

			canvas.appendChild(table);

			// Repos

			div = document.createElement('div');
			div.innerHTML = '<hr /><h2>GitHub.com Repos</h2>';
			canvas.appendChild(div);

			columnDefs = [
				{ heading: 'Key', columnName: 'key' },
				{ heading: 'User Name', columnName: 'user_name' },
				{ heading: 'Repo Name', columnName: 'repo_name' },
				{ heading: 'Latest (tag_name)', columnName: 'tag_name' },
				{ heading: 'Published', columnName: 'published_at' },
				{ heading: 'Details URL', columnName: 'url_details' },
				{ heading: 'Metadata URL', columnName: 'url_api' },
			];

			table = document.createElement('table');

			buildTable(columnDefs, _info.repos, table, (columnDef, result, resultIndex, row, cell) => {

				const value = result[columnDef.columnName];

				if (value === undefined)
					return;

				cell.innerHTML = value;

				switch (columnDef.columnName) {

					case 'url_details':
					case 'url_api':
						cell.innerHTML = `<a href="${value}" target="_blank">${value}</a>`;
						break;
				}
			});

			canvas.appendChild(table);

			// Items

			div = document.createElement('div');
			div.innerHTML = '<hr /><h2>Archive.org Items</h2>';
			canvas.appendChild(div);

			columnDefs = [
				{ heading: 'Key', columnName: 'key' },
				{ heading: 'Type', columnName: 'type' },
				{ heading: 'Tag', columnName: 'tag' },
				{ heading: 'Status', columnName: 'status' },
				{ heading: 'Title', columnName: 'title' },
				{ heading: 'File Count', columnName: 'file_count' },
				{ heading: 'Last Updated', columnName: 'item_last_updated' },
				{ heading: 'Details URL', columnName: 'url_details' },
				{ heading: 'Metadata URL', columnName: 'url_metadata' },
				{ heading: 'Download URL', columnName: 'url_download' },
				{ heading: 'Sub Directory', columnName: 'sub_directory' },
			];

			table = document.createElement('table');

			buildTable(columnDefs, _info.items, table, (columnDef, result, resultIndex, row, cell) => {

				const value = result[columnDef.columnName];

				if (value === undefined)
					return;

				cell.innerHTML = value;

				switch (columnDef.columnName) {

					case 'url_details':
					case 'url_metadata':
					case 'url_download':
						cell.innerHTML = `<a href="${value}" target="_blank">${value}</a>`;
						break;
				}
			});

			canvas.appendChild(table);

			// End Points

			const data = await fetchJson('/api/end_points');

			div = document.createElement('div');
			div.innerHTML = '<hr /><h2>Endpoint Locations</h2>';
			canvas.appendChild(div);

			columnDefs = [
				{ heading: 'Name', columnName: 'name' },
				{ heading: 'Location', columnName: 'location' },
			];

			table = document.createElement('table');

			buildTable(columnDefs, data.results, table, (columnDef, result, resultIndex, row, cell) => {

				const value = result[columnDef.columnName];

				cell.innerHTML = value;

				switch (columnDef.columnName) {

					case 'location':
						cell.innerHTML = `<a href="${value}" target="_blank">${value}</a>`;
						break;
				}
			});

			canvas.appendChild(table);
		}

		//
		// Update
		//
		const update = async () => {

			const canvas = getCanvas();

			const html = `<p>New MAME-AO update avaialable ${_info.version_name_current} => ${_info.version_name_available}</p>` +
				`<a href="${_baseUrl}/api/update">Click here to update immediately.</a>`;

			const div = document.createElement('div');
			div.innerHTML = html;
			canvas.appendChild(div);
		}

		//
		// Store Operations
		//
		const storeOperations = async () => {
			const canvas = getCanvas();

			let html = '';

			html += '<p>Validate the ROM Hash Store, each file will be SHA1 hashed and compared to the filename.</p>';
			html += '<button type="submit" onclick="runCommand(\'.valid rom\'); return false;">Validate ROM</button><br />';

			html += '<hr />';

			html += '<p>Validate the DISK Hash Store, each file will have the SHA1 verified with chdman.exe and compared to the filename.</p>';
			html += '<p>WARNING: This can take a while, each CHD will have its SHA1 calculated to verify it is correct.</p>'
			html += '<button type="submit" onclick="runCommand(\'.valid disk\'); return false;">Validate DISK</button><br />';

			const div = document.createElement('div');
			div.innerHTML = html;
			canvas.appendChild(div);
		}

		//
		// Snaps
		//
		const collectSnaps = async () => {
			const canvas = getCanvas();

			let html = '';

			html += '<p>Copy and paste the directory path or filename here.</p>';
			html += '<input id="directory" type="text" value="" style="width:480px;" /><br /><br />';
			html += '<button type="submit" onclick="runCommand(\'.snap \' + directory.value); return false;">Collect and Move Snaps to Directory</button><br /><br />';
			html += '<button type="submit" onclick="runCommand(\'.svg \' + directory.value); return false;">Convert bitmaps to SVG, single filename or directory for all files</button><br />';
			html += '<p>A report will pop up in the browser when finished. Look at the console shell to check progress.</p>';

			const div = document.createElement('div');
			div.innerHTML = html;
			canvas.appendChild(div);

			document.getElementById('directory').focus();
		}

		//
		// Import
		//
		const importFiles = async () => {

			const canvas = getCanvas();

			let html = '';
			html += '<p>Copy and paste the directory path to import from here.</p>';
			html += '<input id="directory" type="text" value="" style="width:480px;" /><br />';
			html += '<button type="submit" onclick="runCommand(\'.import \' + directory.value); return false;">Start Import</button><br />';
			html += '<p>A report will pop up in the browser when finished. Look at the console shell to check progress.</p>';

			const div = document.createElement('div');
			div.innerHTML = html;
			canvas.appendChild(div);

			document.getElementById('directory').focus();
		}

		//
		// Export
		//
		const exportFiles = async () => {

			const canvas = getCanvas();

			let html = '';
			html += '<p>Copy and paste the directory path to export to here.</p>';
			html += '<select id="exportType"><option value="*">Everything</option><option value="MR">Machine ROM</option><option value="MD">Machine DISK</option><option value="SR">Software ROM</option><option value="SD">Software DISK</option></select><br /><br />';
			html += '<input id="directory" type="text" value="" style="width:480px;" /><br />';
			html += '<button type="submit" onclick="runCommand(\'.export \' + exportType.value + \' \' + directory.value); return false;">Start Export</button><br />';
			html += '<p>A report will pop up in the browser when finished. Look at the console shell to check progress.</p>';

			const div = document.createElement('div');
			div.innerHTML = html;
			canvas.appendChild(div);

			document.getElementById('directory').focus();
		}

		//
		// Saved state
		//
		const saved = async () => {

			const canvas = getCanvas();

			const data = await fetchJson('/api/list');

			const columnDefs = [
				{ heading: 'MAME Version', columnName: 'version' },
				{ heading: 'MAME Binary Time', columnName: 'binary_time' },
				{ heading: 'Save Name', columnName: 'sta_name' },
				{ heading: 'Save Time', columnName: 'sta_time' },
				{ heading: 'Machine Name', columnName: 'sta_machine' },
				{ heading: 'Machine Description', columnName: 'sta_description' },
			];

			const table = document.createElement('table');
			table.style = 'margin-left: auto; margin-right: auto;';

			buildTable(columnDefs, data.results, table, (columnDef, result, resultIndex, row, cell) => {

				switch (columnDef.columnName) {

					case 'version':
						cell.innerHTML = `<a onclick="runCommand('.${result.version}')" href="javascript:void(0);">${result.version}</a>`;
						break;

					case 'sta_machine':
						if (result.sta_machine !== undefined)
							cell.innerHTML = `<a onclick="runCommand('.${result.version} ${result.sta_machine}')" href="javascript:void(0);">${result.sta_machine}</a>`;
						break;

					default:
						if (result[columnDef.columnName] !== undefined)
							cell.innerHTML = result[columnDef.columnName];
						break;
				}
			});

			canvas.appendChild(table);
		}

		//
		// Run Reports
		//
		const runReports = async () => {

			const canvas = getCanvas();

			let html = '';

			html += 'Click report code to run report. It will pop up in default browser when finished.';

			const report_groups = await fetchJson('/api/report_groups');
			const report_types = await fetchJson('/api/report_types');

			report_groups.results.forEach((report_group, index) => {

				if (index > 0)
					html += '<hr />';

				html += `<h2>${report_group.text} (${report_group.key})</h2>`;
				html += `<p>${report_group.description}</p>`;

				html += '<table>';
				html += '<tr><th>key</th><th>code</th><th>text</th><th>description</th></tr>';

				report_types.results.filter(report_type => report_type.group === report_group.key).forEach(report_type => {

					html += `<tr><td>${report_type.key}</td><td><a href="javascript:void(0);" onclick="runCommand('.report ${report_type.code}')" >${report_type.code}</a></td><td>${report_type.text}</td><td>${report_type.description}</td></tr>`;
				});

				html += '</table>';
			});

			const div = document.createElement('div');
			div.innerHTML = html;
			canvas.appendChild(div);
		}

		//
		// View Reports
		//
		const viewReports = async () => {

			const canvas = getCanvas();

			const data = await fetchJson('/api/reports');

			const table = document.createElement('table');
			table.style = 'margin-left: auto; margin-right: auto;';

			const headRow = document.createElement('tr');
			let cell;

			cell = document.createElement('th');
			cell.innerHTML = 'Report Date';
			headRow.appendChild(cell);

			cell = document.createElement('th');
			cell.innerHTML = 'Report Description';
			headRow.appendChild(cell);

			table.appendChild(headRow);

			data.results.forEach((report) => {

				const tableRow = document.createElement('tr');

				let cell;

				cell = document.createElement('td');
				cell.innerHTML = `<a href="${_baseUrl}/api/report?name=${encodeURIComponent(report.name)}" target="_blank">${report.date.replace('T', ' ')}</a>`;
				tableRow.appendChild(cell);

				cell = document.createElement('td');
				cell.innerHTML = `${report.description}`;
				tableRow.appendChild(cell);

				table.appendChild(tableRow);
			});

			canvas.appendChild(table);
		}

		//
		// Genres
		//
		const genres = async () => {

			const canvas = getCanvas();

			const genre_groups = await fetchJson('/api/genre_groups');

			const columnDefs = [
				{ heading: 'Genre Group', columnName: 'group_name' },
				{ heading: 'Status Good', columnName: 'good' },
				{ heading: 'Status Imperfect', columnName: 'imperfect' },
				{ heading: 'Status Preliminary', columnName: 'preliminary' },
			];

			const table = document.createElement('table');
			table.style = 'margin-left: auto; margin-right: auto;';

			buildTable(columnDefs, genre_groups.results, table, (columnDef, result, resultIndex, row, cell) => {

				let html;

				const value = result[columnDef.columnName];

				switch (columnDef.columnName) {

					case 'group_name':
						html = `<a href="${_baseUrl}/genres/${encodeURIComponent(value)}">${value}</a>`;
						break;

					default:
						html = value;
						break;
				}

				if (html === 0)
					html = '';

				cell.innerHTML = html;

			});

			canvas.appendChild(table);
		}

		//
		// Genres Group
		//
		const genresGroup = async () => {

			const canvas = getCanvas();

			let parts = _pathParts[2].split('/');
			const group_name = decodeURIComponent(parts[parts.length - 1]);

			const genres = await fetchJson(`/api/genres?group_name=${encodeURIComponent(group_name)}`);

			const columnDefs = [
				{ heading: 'Genre', columnName: 'genre_name' },
				{ heading: 'Status Good', columnName: 'good' },
				{ heading: 'Status Imperfect', columnName: 'imperfect' },
				{ heading: 'Status Preliminary', columnName: 'preliminary' },
			];

			const table = document.createElement('table');
			table.style = 'margin-left: auto; margin-right: auto;';

			buildTable(columnDefs, genres.results, table, (columnDef, result, resultIndex, row, cell) => {

				let html;

				const value = result[columnDef.columnName];

				switch (columnDef.columnName) {

					case 'genre_name':
						html = `<a href="${_baseUrl}/genres/${encodeURIComponent(group_name)}/${encodeURIComponent(value)}">${value}</a>`;
						break;

					default:
						html = value;
						break;
				}

				if (html === 0)
					html = '';

				cell.innerHTML = html;

			});

			canvas.appendChild(table);
		}

		//
		// Machines in Genre
		//
		const genreMachines = async () => {

			const canvas = getCanvas();

			let parts = _pathParts[3].split('/');
			const genre_name = decodeURIComponent(parts[parts.length - 1]);

			const genres = await fetchJson(`/api/genres?genre_name=${encodeURIComponent(genre_name)}`);
			const genre_id = genres.results[0].genre_id;

			let profileKey = `genre-${genre_id}`;

			const machinesData = await (await fetch(`${_baseUrl}/api/machines?profile=${profileKey}&offset=${_parameters.offset}&search=${_parameters.search}`)).json();

			profileKey = 'everything';

			showMachines(canvas, machinesData, profileKey);
		}

		//
		// Machines in Data Profile
		//
		const machines = async () => {

			const canvas = getCanvas();

			let parts = _pathParts[2].split('/');
			const profileKey = parts[parts.length - 1];

			const machinesData = await fetchJson(`/api/machines?profile=${profileKey}&offset=${_parameters.offset}&search=${_parameters.search}`);

			showMachines(canvas, machinesData, profileKey);
		}

		//
		// Show Machines
		//
		const showMachines = (canvas, machinesData, profileKey) => {

			const columnDefs = [
				{ heading: '', columnName: 'ao_image' },
				{ heading: 'fav', columnName: 'favorite' },
				{ heading: 'name', columnName: 'name' },
				{ heading: 'description', columnName: 'description' },
				{ heading: 'year', columnName: 'year' },
				{ heading: 'manufacturer', columnName: 'manufacturer' },
				{ heading: 'roms', columnName: 'ao_rom_count' },
				{ heading: 'disks', columnName: 'ao_disk_count' },
				{ heading: 'lists', columnName: 'ao_softwarelist_count' },
				{ heading: 'cloneof', columnName: 'cloneof' },
				{ heading: 'romof', columnName: 'romof' },
				{ heading: 'status', columnName: 'status' },
				{ heading: 'emulation', columnName: 'emulation' },
			];

			const table = document.createElement('table');
			table.style = 'width:100%;';

			buildTable(columnDefs, machinesData.results, table, (columnDef, result, resultIndex, row, cell) => {

				const value = result[columnDef.columnName];

				if (value === undefined)
					return;

				cell.innerHTML = value;

				switch (columnDef.columnName) {
					case 'ao_image':
						if (result.ao_softwarelist_count > 0)
							cell.innerHTML = `<a id="${result.name}" href="${_baseUrl}/machines/${profileKey}/${result.name}"><div style="width:128px;height:128px;"><img src="${result.ao_image}" loading="lazy" /></div></a>`;
						else
							cell.innerHTML = `<a id="${result.name}" onclick="runCommand(this.id)" href="javascript:void(0);"><div style="width:128px;height:128px;"><img src="${result.ao_image}" loading="lazy" /></div></a>`;
						break;

					case 'name':
						cell.innerHTML = `<a href="https://mame.spludlow.co.uk/Machine.aspx?name=${result.name}" target="_blank">${result.name}</a>`;
						break;

					case 'cloneof':
						cell.innerHTML = `<a href="/machines/everything?search=${value}">${value}</a>`;
						row.className = (resultIndex % 2) ? 'clone-odd' : 'clone-even';
						break;

					case 'romof':
						cell.innerHTML = `<a href="/machines/everything?search=${value}">${value}</a>`;
						break;

					case 'favorite':
						cell.innerHTML = `<input type="checkbox" id="fav_${result.name}" onclick="changeFavoriteMachine(this.id, ${resultIndex})" ${result.favorite ? 'checked' : ''}>`;
						if (result.favorite === true)
							cell.className = (resultIndex % 2) ? 'fav-odd' : 'fav-even';
						break;

					case 'status':
						cell.className = result.status + (resultIndex % 2 ? '-odd' : '-even');
						break;

				}

				if (cell.innerHTML === '0')
					cell.innerHTML = '';
			});

			const navHtml = navigateHtml(machinesData);

			let html = '';

			html += `<input id="inputText" type="text" value="${_parameters.search}" style="width:480px;" />`;
			html += '<button type="submit" onclick="searchButton(); return false;">Search</button>';
			html += '<hr />';
			html += `<nav>${navHtml}</nav>`;
			html += '<div id="results"></div>';
			html += `<nav>${navHtml}</nav>`;

			const div = document.createElement('div');
			div.innerHTML = html;
			canvas.appendChild(div);

			const results = document.getElementById('results');

			results.appendChild(table);

			if (machinesData.results.length === 0)
				results.insertAdjacentHTML('beforeend', `<p><b>No results - try looking in <a href="/machines/everything?search=${_parameters.search}">Everything</a></b></p>`);

			const inputText = document.getElementById('inputText');
			inputText.focus();
		}
		const changeFavoriteMachine = async (checkBoxId, resultIndex) => {
			const checkBox = document.getElementById(checkBoxId);

			const name = checkBoxId.substring(4);

			const command = checkBox.checked ? ".favm" : ".favmx";

			await runCommand(`${command} ${name}`);

			const row = checkBox.parentElement.parentElement;

			const cell = row.cells[1];
			if (checkBox.checked === false)
				cell.className = '';
			else
				cell.className = (resultIndex % 2) ? 'fav-odd' : 'fav-even';
		}

		//
		// Machine (Show software)
		//
		const machine = async (machineData) => {

			const canvas = getCanvas();

			let parts = _pathParts[4].split('/');
			const softwarelist = parts[parts.length - 1];

			const softwareData = await fetchJson(`/api/software?softwarelist=${softwarelist}&offset=${_parameters.offset}&search=${_parameters.search}&favorites_machine=${machineData.name}`);

			const columnDefs = [
				{ heading: '', columnName: 'ao_image' },
				{ heading: 'fav', columnName: 'favorite' },
				{ heading: 'name', columnName: 'name' },
				{ heading: 'description', columnName: 'description' },
				{ heading: 'year', columnName: 'year' },
				{ heading: 'publisher', columnName: 'publisher' },
				{ heading: 'cloneof', columnName: 'cloneof' },
				{ heading: 'supported', columnName: 'supported' },
			];

			const table = document.createElement('table');
			table.style = 'width:100%;';

			buildTable(columnDefs, softwareData.results, table, (columnDef, result, resultIndex, row, cell) => {

				switch (columnDef.columnName) {
					case 'ao_image':
						cell.innerHTML = `<a id="${result.name}" onclick="runCommand('${machineData.name} ${result.name}')" href="javascript:void(0);"><div style="width:128px;height:128px;"><img src="${result.ao_image}" loading="lazy" /></div></a>`;
						break;

					case 'name':
						cell.innerHTML = `<a href="https://mame.spludlow.co.uk/Software.aspx?list=${result.softwarelist_name}&soft=${result.name}" target="_blank">${result.name}</a>`;
						break;

					case 'favorite':
						cell.innerHTML = `<input type="checkbox" id="fav_${result.name}" onclick="changeFavoriteSoftware(this.id, '${machineData.name}', '${result.softwarelist_name}', ${resultIndex})" ${result.favorite ? 'checked' : ''}>`;
						if (result.favorite === true)
							cell.className = (resultIndex % 2) ? 'fav-odd' : 'fav-even';
						break;

					default:
						cell.innerHTML = result[columnDef.columnName] ?? '';
						break;
				}
			});

			const navHtml = navigateHtml(softwareData);

			let html = '';

			html += `<input id="inputText" type="text" value="${_parameters.search}" style="width:480px;" />`;
			html += '<button type="submit" onclick="searchButton(); return false;">Search</button>';
			html += '<hr />';
			html += `<nav>${navHtml}</nav>`;
			html += '<div id="results"></div>';
			html += `<nav>${navHtml}</nav>`;

			const div = document.createElement('div');
			div.innerHTML = html;
			canvas.appendChild(div);

			const results = document.getElementById('results');

			results.appendChild(table);

			const inputText = document.getElementById('inputText');
			inputText.focus();
		}
		const changeFavoriteSoftware = async (checkBoxId, machineName, listName, resultIndex) => {
			const checkBox = document.getElementById(checkBoxId);

			const softwareName = checkBoxId.substring(4);

			const command = checkBox.checked ? ".favs" : ".favsx";

			await runCommand(`${command} ${machineName} ${listName} ${softwareName}`);

			const row = checkBox.parentElement.parentElement;

			const cell = row.cells[1];
			if (checkBox.checked === false)
				cell.className = '';
			else
				cell.className = (resultIndex % 2) ? 'fav-odd' : 'fav-even';
		}

		const searchButton = async () => {

			const inputText = document.getElementById('inputText');

			document.location = `${_path}?search=${encodeURIComponent(inputText.value)}`;

		}

		const navigateHtml = (data) => {

			const limit = 100;

			const totalPages = Math.ceil(data.total / data.limit);
			const currentPage = (data.offset / data.limit) + 1;

			return `<a href="${_path}?offset=${_parameters.offset - limit}&search=${encodeURIComponent(_parameters.search)}">PREV</a>` +
				'&nbsp; - &nbsp;' +
				`<a href="${_path}?offset=${_parameters.offset + limit}&search=${encodeURIComponent(_parameters.search)}">NEXT</a>` +
				'&nbsp; - &nbsp;' +
				`page: ${currentPage} / ${totalPages} - total: ${data.total} - viewing: ${data.count}`;
		}

		//
		// Tools
		//

		const sleep = ms => new Promise(r => setTimeout(r, ms));

		const fetchJson = async (url, base = _baseUrl) => (await fetch(`${base}${url}`)).json();

		const getCanvas = () => {
			const page = document.getElementById('canvas');
			page.innerHTML = '';
			return page;
		}

		const runCommand = async (line) => {

			const response = await fetch(`${_baseUrl}/api/command?line=${encodeURIComponent(line)}`);

			const result = await response.json();

			if (response.status !== 200)
				alert(result.message);
		}

		const buildTableHeader = (columnDefs, table) => {
			const headRow = document.createElement('tr');
			columnDefs.forEach((columnDef) => {
				const cell = document.createElement('th');
				cell.innerHTML = columnDef.heading;
				headRow.appendChild(cell);
			});
			table.appendChild(headRow);
		}

		const buildTable = (columnDefs, results, table, cellFunction) => {

			buildTableHeader(columnDefs, table);

			results.forEach((result, resultIndex) => {

				const row = document.createElement('tr');

				columnDefs.forEach((columnDef) => {
					const cell = document.createElement('td');
					cellFunction(columnDef, result, resultIndex, row, cell);
					row.appendChild(cell);
				});

				table.appendChild(row);
			});
		}

		const getRequestInfo = () => {

			_baseUrl = window.location.origin;

			_parameters = {};

			if (window.location.href.includes('?')) {

				const parts = window.location.href.split('?')[1].split('&');
				parts.forEach((part) => {
					const pair = part.split('=');
					_parameters[pair[0]] = decodeURIComponent(pair[1]);
				});
			}

			if (_parameters['offset'] === undefined)
				_parameters['offset'] = 0;
			else
				_parameters['offset'] = parseInt(_parameters['offset'], 10);

			if (_parameters['search'] === undefined)
				_parameters['search'] = '';

			_path = document.location.pathname;

			_pathParts = [];

			if (_path === '/') {
				_pathParts.push('/');
			} else {
				_path.split('/').forEach((part) => {
					if (part !== undefined) {
						let prev = '';
						if (_pathParts.length > 1)
							prev = _pathParts[_pathParts.length - 1];

						_pathParts.push(prev + '/' + part);
					}
				});
			}
		}

		const htmlEncode = (html) => html.replace(/[&<>'"]/g,
			tag => ({
				'&': '&amp;',
				'<': '&lt;',
				'>': '&gt;',
				"'": '&#39;',
				'"': '&quot;'
			}[tag]));

		const renderHtmlTable = (data) => {
			if (data == null)
				return 'null';

			if (typeof data !== 'object')
				return htmlEncode(JSON.stringify(data));

			if (Array.isArray(data) === false) {
				data = [data];
			}

			if (data.length === 0)
				return '[]';

			if (typeof data[0] !== 'object')
				return htmlEncode(JSON.stringify(data));

			const columnNames = [];
			data.forEach((row) => {
				Object.keys(row).forEach(columnName => {
					if (columnNames.includes(columnName) === false)
						columnNames.push(columnName);
				});
			});

			let table = '';

			table += '<table>';
			table += '<tr>';
			columnNames.forEach(columnName => {
				table += `<th>${columnName}</th>`;
			});
			table += '</tr>';

			data.forEach((row) => {
				table += '<tr>';
				columnNames.forEach(columnName => {
					let value = '';
					if (row[columnName] !== undefined)
						value = renderHtmlTable(row[columnName]);

					table += `<td>${value}</td>`;
				});
				table += '</tr>';
			});

			table += '</table>';

			return table;
		};

		//
		// Menu
		//

		const displayMenu = () => {

			const versions = `V${_info.version} (${_info.mame_version})`;

			_rootMenu[0].text = `MAME-AO ${versions}`;
			_rootMenu[0].title = versions;

			displayMenuWalk(_rootMenu);

			if (_currentMenu && _currentMenu.menu && _currentMenu.menu[0].href)
				document.location = `${_baseUrl}${_currentMenu.menu[0].href}`;
		}

		const displayMenuWalk = (menu) => {

			const nav = document.getElementById('nav');
			const heading = document.getElementById('heading');

			const table = document.createElement('table');
			table.style = "width: 100%;";

			const row = document.createElement('tr');

			let found;

			menu.forEach((item) => {
				const cell = document.createElement('td');

				let itemClass = 'nav-off';

				if (_pathParts.includes(item.href)) {

					itemClass = 'nav-on';
					found = item;
					document.title = item.title;
					heading.innerHTML = item.title;
				}

				if (_path === item.href)
					_currentMenu = item;

				cell.className = itemClass;

				if (item.style)
					cell.style = item.style;

				cell.innerHTML = `<a href="${item.href}" title="${item.title}" class="${itemClass}">${item.text}</a>`;

				row.appendChild(cell);
			});

			table.appendChild(row);
			nav.appendChild(table);

			if (found && found.menu)
				displayMenuWalk(found.menu);
		}

		//
		// Load
		//

		window.onload = main;

	</script>

</head>
<body>

	<div>
		<a style="float:left;" href="/"><img src="https://mame.spludlow.co.uk/snap/mame-ao-logo.png" /></a>
		<h1 id="heading"></h1>
	</div>

	<nav id="nav">
	</nav>

	<hr />

	<div id="error"></div>

	<form>
		<div id="canvas">
			<p>Loading...</p>
		</div>
	</form>

	<hr />

</body>
</html>
